# Very preliminary design for a workflow engine

Heikki Levanto

This is the result of reading [Mike's white paper](folio-workflow-engine.md), and a few ideas of my own.

## Workflow
A workflow is a template for jobs. It consists of a number of steps, and some
metadata, like what inputs the job requires, what outputs it provides, some
editing history, etc.

## Jobs
A job is a simple thing: A copy of the template, and its internal state and
data, see below. I would like to copy the steps to the job, so editing the
template will not mess with already running jobs.



## Data types
We did the ${variables} pretty well in CF. I propose we copy that construct
into the workflow engine. In short that means that the whole state of the job
is kept in one Json structure. The top level of this structure is divided into
sections like "input", "output", and "tmp". The structure under these is more
fluid, and can change during the life of the job. Having it all in one place
makes it easy to store the state of the job, and to resume it later.

Any step can access any part of this structure with a path like {$.input.userid}
or {$.tmp.records[17].authors[$.tmp.authorindex].lastname}. Maybe we can use
some existing jsonPath tools, but it would not be hard to roll our own. Such a
path can refer to a single value (string, number, or boolean), an array, or a
structure.

This means that we do not need to define basic data types like users or items,
everything is in Json. Since all serious processing will happen in the back
end modules anyway, using plain json for the glue layer should be fine. Of course
we can build steps that operate on specific kinds of objects, but we can get 
started, and pretty far, without. This way, the workflow engine does not have
to know that it is running under Folio, or dealing with workflows that pertain
to libraries.

### Predefined data structures
The top level structure should have some well known elements that almost all
jobs can use.

* Input. Input parameters for the job. The workflow can specify which inputs
are required, and which are optional.
* Output. The results of the workflow. For real workflows this can be as little
as a flag saying that it is done - all real data has been stored in the database.
But for subroutines, the outputs are important, since they will be used by the
calling jobs.
* Temp space for manipulating data.
* Log. Will contain at least an execution trace, showing what steps were
executed, when, and with what results. Later UI will have nice filtering
options to show various levels of detail. May also contain other log files,
like lists of records processed, and their success codes, etc.
* Metadata. Who sarted the job, when, and from what version of the workflow.
Also stuff like due date (so we can highlight late jobs on the UI), tags,
and status, and a list of people to be notified about status changes.
* Comments. We saw in the trello demo that comments are very useful. The
could also be implemented using our mod-notes, but I feel that these are
important enough to consider them first-class citizens. Also, by keeping them
in the job structure, steps can add comments etc.
* System. These are mostly read-only for the job, and include the instruction
pointer that tells which step to execute next, a auth token to be used in all 
operations, and who knows what else.

## Initial steps
I believe that we can get pretty far with the steps below. If it turns out that
some pattern repeat often enough, we can make special steps for those, or maybe
workflow subroutines that can be reused. For example, sending a notification
to some user can be done by POSTing a notification to mod-notify. But it would
be more friendly for the users to have a step that handles most of the details.

All steps should have the notion that they can fail, and have settings to control
how failures are handled. At least options to ignore errors, abort the current
iteration (if in a loop), or terminate the whole job. Maybe also an option to
set a $-variable, so we can look at the failure in some other steps and take
suitable action.

All steps should also have a label, maybe autogenerated when editing the
workflow, so that we can know which step we are talking about in the logs,
traces, etc.


### Folio request
GET, POST, PUT, or DELETE request to some back end module. This is how we get
data into our job, and back to the system.
* Request type
* path
* Post data (reference to a $variable)
* Where to put the resulting data
* Where to put error messages
The step should know the version of the interface it talks to, and fail if
services have been upgraded to incompatible versions.

### Transform data
A simple regular expression, taking data from one $.variable, and putting the
result into another (or the same one). Options to fail if no matches, etc, as 
we have seen in CF. 

### Suspend job
Has a condition block that gets evaluated every now and then to see if things
have changed, and the job could continue. This can be a simple lookup in some
Folio service (has the book been received yet), or a calculation (should the
patron have returned the item). Some kind of hint to say how often a job should
wake up and check. Later we can elaborate on this, add time-outs and nagging
notifications. 

I imagine that some kind of UI can also wake any job and cause it to check its 
condition immediately. Maybe other triggers can do the same, waking is a fairly
harmless operation, it just checks the condition.

### Some kind of looping and conditional
These require the concept of blocks of steps. A simple for-each loop over an 
array will probably be the most useful.  A loop should probably have a name
or label associated with it, so we can control on what level to abort things
in case of errors. If we are looping through authors within books, and 
run into a problem, we may decide to skip that book.

### Run another workflow
So we can have subroutines, and can organize large workflows into smaller pieces.
I expect we may end up with a fairly large library of reusable routines, some
generally useful, some for given library only, some personal.

### Checklist
Stolen from the Trello demo, a checklist consists of a title, comment,
optionally a list of people to be notified of all changes, and a list of
checkboxes. Each box has a caption, and the step keeps track of how many
percent of its boxes have been checked. In our version, those checkboxes
should of course live in the $variables, so that other steps can check them
too, although mostly they will be done by humans. 
 
